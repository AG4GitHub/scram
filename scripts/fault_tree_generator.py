#!/usr/bin/env python
"""fault_tree_generator.py

A script to generate a fault tree of various complexities. The generated
fault tree is put into XML file with OpenPSA MEF ready for analysis.
This script should help create complex fault trees to test analysis tools.
"""

import Queue
import random

import argparse as ap

class Gate(object):
    """Representation of a gate of a fault tree.
    """
    num_gates = 0  # to keep track of gates and to name them
    def __init__(self):
        Gate.num_gates += 1
        self.name = "G" + str(Gate.num_gates)
        self.p_children = set()  # children that are primary events
        self.g_children = set()  # children that are gates
        self.gate = ""  # type of a gate

class TopEvent(object):
    def __init__(self):
        self.name = "TopEvent"  # default name for a top event
        self.p_children = set()  # children that are primary events
        self.i_children = set()  # children that are intermediate events
        self.gate = ""

class InterEvent(object):
    ninter = 0  # number of intermediate events
    def __init__(self):
        InterEvent.ninter += 1
        self.name = "G" + str(InterEvent.ninter)
        self.p_children = set()
        self.i_children = set()
        self.gate = ""

class PrimaryEvent(object):
    nprime = 0  # number of primary events
    def __init__(self):
        PrimaryEvent.nprime += 1
        self.name = "E" + str(PrimaryEvent.nprime)
        self.prob = 0  # probability

def write_info(args):
    """Writes the information about the setup and generated fault tree.

    This function uses the output destination from the arguments.

    Args:
        args: Command-line configurations.
    """
    t_file = open(args.out, "w")
    t_file.write("<?xml version=\"1.0\"?>\n")
    t_file.write("<!--\nThis is an input file for SCRAM. It is autogenerated\n"
        "with the following parameters:\n\n"
        "The seed of a random number generator: " + str(args.seed) + "\n"
        "The number of unique primary events: " + str(args.nprimary) + "\n"
        "The average number of children per intermediate event: " +
        str(args.nchildren) + "\n"
        "Primary events to intermediate events ratio per new node: " +
        str(args.ratio) + "\n"
        "Approximate percentage of repeated primary event in the tree: " +
        str(args.reuse) + "\n"
        "Maximum probability for primary events: " + str(args.maxprob) + "\n"
        "Minimum probability for primary events: " + str(args.minprob) + "\n"
        "Minimal number of primary events for a root node: "
        + str(args.topprime) + "\n"
        "Name of a file to write the fault tree: " + str(args.out) + "\n"
        "-->\n\n"
        )

def write_model_data(t_file, primary_events):
    """Appends model data with primary event descriptions.
    """
    # Print probabilities of primary events
    t_file.write("<model-data>\n")
    for p in primary_events:
        t_file.write("<define-basic-event name=\"" + p.name + "\">\n"
                     "<float value=\"" + str(p.prob) + "\"/>\n"
                     "</define-basic-event>\n")

    t_file.write("</model-data>\n")

def write_results(args, top_event, primary_events):
    """Writes results of a generated fault tree.
    """
    write_info(args)
    t_file = open(args.out, "a")

    t_file.write("<opsa-mef>\n")
    t_file.write("<define-fault-tree name=\"Autogenerated\">\n")

    # Container for not yet initialized intermediate events.
    gates_queue = Queue.Queue()

    def write_node(inter_event, o_file):
        """Print children for the intermediate event.
        Note that it also updates the queue for intermediate events.
        """

        o_file.write("<define-gate name=\"" + inter_event.name + "\">\n")
        o_file.write("<" + inter_event.gate + ">\n")
        # Print primary events
        for p in inter_event.p_children:
            o_file.write("<basic-event name=\"" + p.name + "\"/>\n")

        # Print intermediate events
        for i in inter_event.i_children:
            o_file.write("<gate name=\"" + i.name + "\"/>\n")
            # Update the queue
            gates_queue.put(i)

        o_file.write("</" + inter_event.gate + ">\n")
        o_file.write("</define-gate>\n")

    # Write top event and update queue of intermediate events
    # Write top event and update queue of intermediate events
    write_node(top_event, t_file)

    # Proceed with intermediate events
    while not gates_queue.empty():
        i_event = gates_queue.get()
        write_node(i_event, t_file)

    t_file.write("</define-fault-tree>\n")

    write_model_data(t_file, primary_events)

    t_file.write("</opsa-mef>")
    t_file.close()

def generate_fault_tree(args):
    """Generates a fault tree of specified complexity from command-line
    arguments.

    Args:
        args: Configurations for fault tree construction.
    """
    # Container for created primary events.
    primary_events = []

    # Supported types of gates.
    types = ["or", "and"]

    # Minimum number of children per intermediate event.
    min_children = 2

    # Maximum number of children.
    max_children = args.nchildren * 2 - min_children

    # Tree generation.
    # Start with a top event.
    top_event = TopEvent()
    top_event.name = args.root
    top_event.gate = random.choice(types)
    child_size = random.randint(min_children, max_children)

    # Configuring child size for the top event.
    if args.ctop:
        child_size = args.ctop
    elif child_size < args.topprime:
        child_size = args.topprime

    # Container for not yet initialized intermediate events.
    gates_queue = Queue.Queue()

    def create_inter(parent):
        inter_event = InterEvent()
        inter_event.gate = random.choice(types)
        parent.i_children.add(inter_event)
        gates_queue.put(inter_event)

    def create_primary(parent):
        prime_event = PrimaryEvent()
        prime_event.prob = random.uniform(args.minprob, args.maxprob)
        primary_events.append(prime_event)
        parent.p_children.add(prime_event)


    # Initialize the top root node.
    while (len(top_event.p_children) + len(top_event.i_children)) < child_size:
        while len(top_event.p_children) < args.topprime:
            create_primary(top_event)
        create_inter(top_event)

    # Initialize intermediate events.
    while not gates_queue.empty():
        # Get the intermediate event to intialize
        init_inter = gates_queue.get()

        # Sample children size
        child_size = random.randint(min_children, max_children)

        while (len(init_inter.p_children) +
               len(init_inter.i_children)) < child_size:
            # Case when the number of primary events is already satisfied
            if len(primary_events) == args.nprimary:
                # Reuse already initialized events only
                init_inter.p_children.add(random.choice(primary_events))
                continue

            # Sample inter events vs. primary events
            s_ratio = random.random()
            if s_ratio < (1.0/(1 + args.ratio)):
                create_inter(init_inter)
            else:
                # Create a primary event
                # Sample reuse
                s_reuse = random.random()
                if s_reuse < args.reuse and not len(primary_events) == 0:
                    # Reuse an already initialized primary event
                    init_inter.p_children.add(random.choice(primary_events))
                else:
                    create_primary(init_inter)

            # Corner case when not enough new primary events initialized, but
            # ther are no more intemediate events due to low ratio.
            if gates_queue.empty() and (len(primary_events) < args.nprimary):
                # Initialize one more intermediate event.
                # This is a naive implementation, so
                # there might be another algorithm in future.
                create_inter(init_inter)

    # Write output files
    write_results(args, top_event, primary_events)

def check_if_positive(desc, val):
    """Verifies that the value is potive or zero for the supplied argument.

    Args:
        desc: The description of the argument from the command-line.
        val: The value of the argument.

    Raises:
        ArgumentTypeError: The value is negative.
    """
    if val < 0:
        raise ap.ArgumentTypeError(desc + " is negative")

def check_if_less(desc, val, ref):
    """Verifies that the value is less than some reference for
    the supplied argument.

    Args:
        desc: The description of the argument from the command-line.
        val: The value of the argument.
        ref: The reference value.

    Raises:
        ArgumentTypeError: The value is more than the reference.
    """
    if val > ref:
        raise ap.ArgumentTypeError(desc + " is more than " + str(ref))

def main():
    """Verifies arguments and calls fault tree generator functions."""
    description = "A script to create a fault tree of an arbitrary size and"\
                  " complexity."

    parser = ap.ArgumentParser(description=description)

    root = "the name for the root gate"
    parser.add_argument("--root", type=str, help=root, default="root")

    seed = "the seed of a random number generator"
    parser.add_argument("--seed", type=int, help=seed, default=123)

    nprimary = "the number of unique primary events"
    parser.add_argument("-p", "--nprimary", type=int, help=nprimary,
                        default=10)

    nchildren = "the average number of children per gate"
    parser.add_argument("-c", "--nchildren", type=int, help=nchildren,
                        default=3)

    ratio = "primary events to gates ratio per a new gate"
    parser.add_argument("--ratio", type=float, help=ratio,
                        default=2)

    reuse = "approximate percentage of repeated primary events in the tree"
    parser.add_argument("--reuse", type=float, help=reuse,
                        default=0.1)

    maxprob = "maximum probability for primary events"
    parser.add_argument("--maxprob", type=float, help=maxprob,
                        default=0.1)

    minprob = "minimum probability for primary events"
    parser.add_argument("--minprob", type=float, help=minprob,
                        default=0.001)

    topprime = "minimal number of primary events for a root node"
    parser.add_argument("--topprime", type=int, help=topprime,
                        default=0)

    ctop = "minimal number of children for a root node"
    parser.add_argument("-n", "--ctop", type=int, help=ctop,
                        default=0)

    out = "output file to write the generated fault tree"
    parser.add_argument("-o", "--out", help=out, default="fault_tree.xml")

    args = parser.parse_args()

    # Check for validity of arguments
    check_if_positive(ctop, args.ctop)
    check_if_positive(topprime, args.topprime)
    check_if_positive(ratio, args.ratio)
    check_if_positive(nchildren, args.nchildren)
    check_if_positive(nprimary, args.nprimary)
    check_if_positive(minprob, args.minprob)
    check_if_positive(maxprob, args.maxprob)
    check_if_positive(reuse, args.reuse)

    check_if_less(reuse, args.reuse, 0.9)
    check_if_less(maxprob, args.maxprob, 1)
    check_if_less(minprob, args.minprob, 1)

    if args.maxprob < args.minprob:
        raise ap.ArgumentTypeError("Max probability < Min probability")

    if args.topprime > args.nprimary:
        raise ap.ArgumentTypeError("topprime > # of total primary events")

    if args.topprime > args.ctop:
        raise ap.ArgumentTypeError("topprime > # of children for top")

    # Set the seed for this tree generator.
    random.seed(args.seed)

    generate_fault_tree(args)


if __name__ == "__main__":
    main()
